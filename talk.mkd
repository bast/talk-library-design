name: inverse
layout: true
class: center, middle, inverse

---

# Library design in a modular world

## Radovan Bast

Licensed under [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/).
Code examples: [OSI](http://opensource.org)-approved [MIT license](http://opensource.org/licenses/mit-license.html).

---

layout: false

## Modular design is good

### Examples

- Lego
- Car manufacturing
- Design of your phone or laptop
- Modular composition when you order a laptop
- Success of USB
- Study programs

### Advantages

- Composability
- Leveraging functionality
- Separation of concerns

---

## Library design in a modular world: how?

<img src="img/joe-paradiso-modular-synth-front.png" style="width: 500px;"/>

- Copyright Joe Paradiso (MIT)

---

## Coupling and cohesion

- Strong coupling

![](img/strong-coupling.svg)

- Loose coupling
    - Easier to reassemble
    - Easier to understand

![](img/loose-coupling.svg)

---

## Coupling and cohesion

- Low cohesion: difficult to maintain, test, reuse, or even understand
    - Non-cohesive code has unnecessary dependencies
    - Swiss army knife modules

![](img/low-cohesion.svg)

- High cohesion: associated with robustness, reliability, reusability, and understandability
    - Do one thing only and do it well
    - API of cohesive code changes less over time

![](img/high-cohesion.svg)

---

## Coupling and cohesion

- Minimize dependencies
- Prefer loose coupling and high cohesion

<img src="img/wires.jpg" style="width: 500px;"/>

---

## Surface area

- As we break up the code into libraries
  the surface area increases

---

## Own development history

- Decouple the development history
- Each unit should have its own Git history/repository

---

## C interface

- English is to humans what C is to programs
- C is the common language
- Basically any language can talk to a C interface
- Do create a C interface for your code
- Better than Fortran interface (the latter imposes compilation
  order and introduces compiler dependence)

---

## Testable on its own

---

## Clear API

- Isolated
- Documented
- Versioned
- Tested

---

## Encapsulation

- Hide internals by language or by convention

---

## Core language

---

## Enemy of the state

---

## Keep I/O on the outside and connected

---

## Namespaces

"Will somebody clean up the butts?" [citation needed]

- This has a different meaning in the namespace "cigarette factory"
  and in the namespace "nursery"
- "Namespaces are one honking great idea -- let's do more of those!" [Zen of Python]

---

## Namespace protection in Python

- Bad
```python
from mymodule import *
```

- Better
```python
from mymodule import function1, function2
```

- Also good
```python
import mymodule
```

- Consider importing modules at function level and not at module level

---

## Namespace protection in Fortran

- Bad
```fortran
use mymodule
```

- Better
```fortran
use mymodule, only: function1, function2
```

- Consider importing modules at function level and not at module level

---

## API

### We will discuss three API examples

- Stateless API
- API with state: new/compute/delete
- API with context

---

## Stateless API

### Example: BLAS

```fortran
f = ddot(1000, vector_a, 1, vector_b, 1)
```

- From the client perspective there is no state
- Sometimes libraries with "stateless" API have internal state (caching, memoization)

### Advantage

- We only need to consider this one call to understand and predict what will happen

### Disadvantages

- The library may need to recompute expensive intermediates at every call
- Typically many arguments

---

## API with state

- We split API into epochs
    - new/init
    - compute
    - delete/finalize

### Example

- MPI

### Advantage

- We can avoid possibly costly initialization at each compute call

### Disadvantages

- Order matters
- We have to remember to clean up
- Only one context at a time

---

## API with state

### Another example: we program our own bank

```python
bank_new()

bank_deposit(100.0)
bank_deposit(100.0)

bank_withdraw(50.0)

my_balance = bank_get_balance()

bank_free()
```

- Problem: We have to close the account before opening a new one

---

## API with state

### It would be great to have more contexts

```python
account1 = bank_new()

bank_deposit(account1, 100.0)
bank_deposit(account1, 100.0)

account2 = bank_new()

bank_deposit(account2, 200.0)
bank_deposit(account2, 200.0)

bank_withdraw(account1, 50.0)

balance1 = bank_get_balance(account1)
balance2 = bank_get_balance(account2)

bank_free(account1)
bank_free(account2)
```

---

## API with context

- Allows multiple contexts open at the same time

### Example: FFTW

```c
fftw_complex in[N], out[N];
fftw_plan p;
...
p = fftw_create_plan(N, FFTW_FORWARD, FFTW_ESTIMATE);
...
fftw_one(p, in, out);
...
fftw_destroy_plan(p);
```

---

## Context-aware API in different languages

- Shows how to implement and use context-aware APIs in C++, Fortran, and Python
  with a C interface.
  Inspired by Armin Ronacher's
  ["Beautiful Native Libraries"](http://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/):
  https://github.com/bast/context-api-example

```
.
|-- api
|   |-- example.h   (C interface)
|   `-- example.py  (Python interface)
|-- src
|   |-- bank.cpp    (C++ library)
|   |-- bank.f90    (Fortran library)
|   `-- bank.h      (C++ library)
`-- test
    |-- test.cpp    (C++ client)
    |-- test.f90    (Fortran client)
    `-- test.py     (Python client; automatically tested)
```

---

## Complexity/viscosity

---

## Memory cleanup
